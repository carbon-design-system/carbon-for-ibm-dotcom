<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: internal/vendor/@carbon/ibmdotcom-utilities/utilities/StickyHeader/StickyHeader.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: internal/vendor/@carbon/ibmdotcom-utilities/utilities/StickyHeader/StickyHeader.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol &amp;&amp; "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o &amp;&amp; "function" == typeof Symbol &amp;&amp; o.constructor === Symbol &amp;&amp; o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t &lt; r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o &amp;&amp; (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r &amp;&amp; _defineProperties(e.prototype, r), t &amp;&amp; _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Copyright IBM Corp. 2016, 2024
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { baseFontSize, breakpoints } from '@carbon/layout';
import root from 'window-or-global';
import settings from '../settings/settings.js';
var prefix = settings.prefix,
  c4dPrefix = settings.stablePrefix;
var ddsPrefix = 'dds';
var bxPrefix = 'bx';
var gridBreakpoint = parseFloat(breakpoints.lg.width) * baseFontSize;
var StickyHeader = /*#__PURE__*/function () {
  function StickyHeader() {
    _classCallCheck(this, StickyHeader);
    this.ownerDocument = root.document;
    this._state = {
      cumulativeOffset: 0,
      hasBanner: false,
      leadspaceSearchThreshold: 0,
      mastheadL0IsActive: false,
      mastheadL1IsActive: false,
      maxScrollaway: 0,
      scrollPosPrevious: 0,
      scrollPos: 0,
      searchIsAtTop: false,
      tocShouldStick: false,
      tocIsAtTop: false,
      tocIsAtSearch: false
    };
    this._elements = {
      banner: undefined,
      leadspaceSearch: undefined,
      leadspaceSearchBar: undefined,
      leadspaceSearchInput: undefined,
      localeModal: undefined,
      masthead: undefined,
      mastheadL0: undefined,
      mastheadL1: undefined,
      tableOfContents: undefined,
      tableOfContentsInnerBar: undefined
    };
    this._throttled = false;
    this._resizeObserver = new ResizeObserver(this._handleResize.bind(this));
    root.addEventListener('scroll', this._throttledHandler.bind(this));
  }

  /**
   * Create (if needed) and return the globally-scoped instance of `this`.
   */
  return _createClass(StickyHeader, [{
    key: "height",
    get: function get() {
      return this._state.cumulativeOffset;
    }

    /**
     * Compares the tag name of the component provided to what we expect it to be
     *
     * @param {HTMLElement} component The component provided
     * @param {string} expected The lowercase tag name expected
     * @throws {TypeError} Throws error if component tag name doesn't match expected string
     * @returns {boolean} Returns true if component tag name matches expected string
     */
  }, {
    key: "_validateComponent",
    value: function _validateComponent(component, expected) {
      var received = component.tagName.toLowerCase();
      if (received !== expected) {
        // TODO: don't check for v1/v2 compatibility after v1 EOL.
        if (received.split('-').splice(1).join('-') !== expected.split('-').splice(1).join('-')) {
          throw new TypeError("".concat(expected, " expected, ").concat(received, " provided"));
        } else {
          var message = ["Mixed prefixes detected.\n", "expected ".concat(expected, ", found ").concat(received, ".")];
          console.warn(message.join(''));
          return true;
        }
      } else {
        return true;
      }
    }

    /**
     * Helper method to query for either C4IBM v1.x or v2.x sub-elements;
     *
     * @param {*} element The C4IBM element.
     * @param {*} v1Func The querying function to run if using a C4IBM v1.x element.
     * @param {*} v2Func The querying function to run if using a C4IBM v2.x element.
     */
  }, {
    key: "_updateRefsV1orV2",
    value: function _updateRefsV1orV2(element, v1Func, v2Func) {
      var elementPrefix = element.tagName.toLowerCase().split('-')[0];
      if (elementPrefix === ddsPrefix) {
        v1Func.bind(this)();
      } else if (elementPrefix === c4dPrefix) {
        v2Func.bind(this)();
      } else {
        throw new Error("\n        Could not find sub-elements for ".concat(element.tagName.toLowerCase(), ".\n      "));
      }
    }

    /**
     * Temporary method to find v1 leadspace sub-elements.
     */
  }, {
    key: "_updateLeadspaceRefsV1",
    value: function _updateLeadspaceRefsV1() {
      var leadspaceSearch = this._elements.leadspaceSearch;
      this._elements.leadspaceSearchBar = leadspaceSearch.shadowRoot.querySelector(".".concat(bxPrefix, "--search-container"));
      this._elements.leadspaceSearchInput = leadspaceSearch.querySelector("".concat(ddsPrefix, "-search-with-typeahead"));
    }

    /**
     * Temporary method to find v2 leadspace sub-elements.
     */
  }, {
    key: "_updateLeadspaceRefsV2",
    value: function _updateLeadspaceRefsV2() {
      var leadspaceSearch = this._elements.leadspaceSearch;
      this._elements.leadspaceSearchBar = leadspaceSearch.shadowRoot.querySelector(".".concat(prefix, "--search-container"));
      this._elements.leadspaceSearchInput = leadspaceSearch.querySelector("".concat(c4dPrefix, "-search-with-typeahead"));
    }

    /**
     * Temporary method to find v1 masthead sub-elements.
     */
  }, {
    key: "_updateMastheadRefsV1",
    value: function _updateMastheadRefsV1() {
      var masthead = this._elements.masthead;
      this._elements.mastheadL0 = masthead.shadowRoot.querySelector(".".concat(bxPrefix, "--masthead__l0"));
      this._elements.mastheadL1 = masthead.querySelector("".concat(ddsPrefix, "-masthead-l1"));
    }

    /**
     * Temporary method to find v2 masthead sub-elements.
     */
  }, {
    key: "_updateMastheadRefsV2",
    value: function _updateMastheadRefsV2() {
      var masthead = this._elements.masthead;
      this._elements.mastheadL0 = masthead.shadowRoot.querySelector(".".concat(prefix, "--masthead__l0"));
      this._elements.mastheadL1 = masthead.querySelector("".concat(c4dPrefix, "-masthead-l1"));
    }

    /**
     * Temporary method to find v1 table of contents sub-elements.
     */
  }, {
    key: "_updateTableOfContentsRefsV1",
    value: function _updateTableOfContentsRefsV1() {
      var toc = this._elements.tableOfContents;
      var tocRoot = toc.shadowRoot;
      var selectors = {
        desktop: {
          vertical: ".".concat(ddsPrefix, "-ce--table-of-contents__items-container"),
          horizontal: ".".concat(bxPrefix, "--tableofcontents__navbar")
        },
        mobile: {
          vertical: ".".concat(bxPrefix, "--tableofcontents__sidebar"),
          horizontal: ".".concat(bxPrefix, "--tableofcontents__navbar")
        }
      };
      var viewportDimension = window.innerWidth >= gridBreakpoint ? 'desktop' : 'mobile';
      this._elements.tableOfContentsInnerBar = tocRoot.querySelector(selectors[viewportDimension][toc.layout || 'vertical']);
    }

    /**
     * Temporary method to find v2 table of contents sub-elements.
     */
  }, {
    key: "_updateTableOfContentsRefsV2",
    value: function _updateTableOfContentsRefsV2() {
      var toc = this._elements.tableOfContents;
      var tocRoot = toc.shadowRoot;
      this._elements.tableOfContentsInnerBar = tocRoot.querySelector(window.innerWidth >= gridBreakpoint &amp;&amp; (toc === null || toc === void 0 ? void 0 : toc.layout) !== 'horizontal' ? ".".concat(c4dPrefix, "-ce--table-of-contents__items-container") : ".".concat(prefix, "--tableofcontents__navbar"));
    }

    /**
     * Stores references to TOC sub-elements that are relevant to current viewport
     * dimensions.
     */
  }, {
    key: "_updateTableOfContentsRefs",
    value: function _updateTableOfContentsRefs() {
      var toc = this._elements.tableOfContents;
      this._updateRefsV1orV2(toc, this._updateTableOfContentsRefsV1, this._updateTableOfContentsRefsV2);
    }
  }, {
    key: "banner",
    set: function set(component) {
      if (this._validateComponent(component, "".concat(c4dPrefix, "-global-banner"))) {
        this._elements.banner = component;
        this._state.hasBanner = true;
        if (this._elements.masthead) {
          this._elements.masthead.setAttribute('with-banner', '');
        }
        this._manageStickyElements();
      }
    }
  }, {
    key: "leadspaceSearch",
    set: function set(component) {
      if (this._validateComponent(component, "".concat(c4dPrefix, "-leadspace-with-search"))) {
        this._elements.leadspaceSearch = component;
        this._updateRefsV1orV2(component, this._updateLeadspaceRefsV1, this._updateLeadspaceRefsV2);
        this._state.leadspaceSearchThreshold = parseInt(window.getComputedStyle(this._elements.leadspaceSearchBar).paddingBottom) - 16;
        this._manageStickyElements();
      }
    }
  }, {
    key: "localeModal",
    set: function set(component) {
      if (this._validateComponent(component, "".concat(c4dPrefix, "-locale-modal"))) {
        this._elements.localeModal = component;
        this._manageStickyElements();
      }
    }
  }, {
    key: "masthead",
    set: function set(component) {
      if (this._validateComponent(component, "".concat(c4dPrefix, "-masthead"))) {
        this._elements.masthead = component;
        if (this._elements.banner) {
          this._elements.masthead.setAttribute('with-banner', '');
        }
        this._updateRefsV1orV2(component, this._updateMastheadRefsV1, this._updateMastheadRefsV2);
        this._manageStickyElements();
      }
    }
  }, {
    key: "tableOfContents",
    set: function set(component) {
      if (this._validateComponent(component, "".concat(c4dPrefix, "-table-of-contents"))) {
        this._elements.tableOfContents = component;
        this._updateTableOfContentsRefs();
        this._resizeObserver.observe(this._elements.tableOfContents);
        this._manageStickyElements();
      }
    }

    /**
     * Rate-limits the scroll event handler
     */
  }, {
    key: "_throttledHandler",
    value: function _throttledHandler() {
      var _this = this;
      if (!this._throttled) {
        this._throttled = true;
        this._manageStickyElements();
        setTimeout(function () {
          _this._throttled = false;
        }, 20);
      }
    }
  }, {
    key: "_handleResize",
    value: function _handleResize() {
      var hasBanner = this._state._hasBanner;
      var _this$_elements = this._elements,
        masthead = _this$_elements.masthead,
        toc = _this$_elements.tableOfContents,
        leadspaceSearchBar = _this$_elements.leadspaceSearchBar;
      if (toc &amp;&amp; masthead) {
        this._updateTableOfContentsRefs();
        if (window.innerWidth >= gridBreakpoint &amp;&amp; toc.layout !== 'horizontal' &amp;&amp; !hasBanner) {
          masthead.style.insetBlockStart = '0';
        } else {
          // This has to happen after the _updateTableOfContentsRefs method.
          var tocInner = this._elements.tableOfContentsInnerBar;
          if (masthead.offsetTop === 0) {
            tocInner.style.insetBlockStart = "".concat(masthead.offsetHeight, "px");
          }
        }
        this._manageStickyElements();
      }
      if (leadspaceSearchBar) {
        this._state.leadspaceSearchThreshold = parseInt(window.getComputedStyle(leadspaceSearchBar).paddingBottom) - 16;
      }
    }

    /**
     * Handles the banner given the current scroll position.
     */
  }, {
    key: "_handleBanner",
    value: function _handleBanner() {
      var banner = this._elements.banner;
      var scrollPos = this._state.scrollPos;
      this._state.cumulativeOffset += Math.max(banner.offsetHeight - scrollPos, 0);
    }

    /**
     * Handles the masthead given the current scroll position.
     */
  }, {
    key: "_handleMasthead",
    value: function _handleMasthead() {
      var masthead = this._elements.masthead;
      masthead.style.transition = 'none';
      masthead.style.insetBlockStart = "".concat(this._state.cumulativeOffset, "px");

      // Masthead always sticks, therefore always add its height.
      this._state.cumulativeOffset += masthead.offsetHeight;
    }

    /**
     * Handles the table of contents given the current scroll position.
     */
  }, {
    key: "_handleToc",
    value: function _handleToc() {
      var tableOfContentsInnerBar = this._elements.tableOfContentsInnerBar;
      var tocShouldStick = this._state.tocShouldStick;
      tableOfContentsInnerBar.style.transition = 'none';
      tableOfContentsInnerBar.style.insetBlockStart = "".concat(this._state.cumulativeOffset, "px");
      var tocIsStuck = Math.round(tableOfContentsInnerBar.getBoundingClientRect().top) &lt;= this._state.cumulativeOffset + 1;
      if (tocShouldStick &amp;&amp; tocIsStuck) {
        this._state.cumulativeOffset += tableOfContentsInnerBar.offsetHeight;
      }
    }

    /**
     * Handles the leadspace search given the current scroll position.
     */
  }, {
    key: "_handleLeadspaceSearch",
    value: function _handleLeadspaceSearch() {
      var _this$_elements2 = this._elements,
        leadspaceSearch = _this$_elements2.leadspaceSearch,
        leadspaceSearchBar = _this$_elements2.leadspaceSearchBar,
        leadspaceSearchInput = _this$_elements2.leadspaceSearchInput;
      var leadspaceSearchThreshold = this._state.leadspaceSearchThreshold;
      var searchShouldBeSticky = leadspaceSearch.getBoundingClientRect().bottom &lt;= leadspaceSearchThreshold;
      var searchIsSticky = leadspaceSearch.hasAttribute('sticky-search');
      if (searchShouldBeSticky) {
        if (!searchIsSticky) {
          leadspaceSearch.style.paddingBottom = "".concat(leadspaceSearchBar.offsetHeight, "px");
          leadspaceSearch.setAttribute('sticky-search', '');
          leadspaceSearchInput.setAttribute('large', '');
          window.requestAnimationFrame(function () {
            leadspaceSearchBar.style.transitionDuration = '110ms';
            leadspaceSearchBar.style.transform = 'translateY(0)';
          });
        }
        leadspaceSearchBar.style.insetBlockStart = "".concat(this._state.cumulativeOffset, "px");
        this._state.cumulativeOffset += leadspaceSearchBar.offsetHeight;
      } else if (searchIsSticky) {
        leadspaceSearch.style.paddingBottom = '';
        leadspaceSearch.removeAttribute('sticky-search');
        leadspaceSearchInput.removeAttribute('large');
        leadspaceSearchBar.style.transitionDuration = '';
        leadspaceSearchBar.style.transform = '';
        leadspaceSearchBar.style.insetBlockStart = '';
      }
    }

    /**
     * Calculates a value matching the height of all components that are allowed
     * to hide above the viewport.
     *
     * Adding an item's height to this value indicates we expect it to be hidden
     * above the viewport.
     *
     * Items that stick, in order
     * - L0
     * - L1
     * - The TOC in horizontal bar form
     * - The leadspace with search (if no TOC)
     */
  }, {
    key: "_calculateMaxScrollaway",
    value: function _calculateMaxScrollaway() {
      var _this$_elements3 = this._elements,
        masthead = _this$_elements3.masthead,
        mastheadL0 = _this$_elements3.mastheadL0,
        mastheadL1 = _this$_elements3.mastheadL1,
        tableOfContents = _this$_elements3.tableOfContents,
        tableOfContentsInnerBar = _this$_elements3.tableOfContentsInnerBar,
        leadspaceSearchBar = _this$_elements3.leadspaceSearchBar;

      // Reset the value before performing any further calculations.
      this._state.maxScrollaway = 0;

      // Collect conditions we may want to test for to make logic easier to read.
      this._state.tocShouldStick = tableOfContents ? tableOfContents.layout === 'horizontal' || window.innerWidth &lt; gridBreakpoint : false;
      this._state.tocIsAtTop = tableOfContentsInnerBar ? tableOfContentsInnerBar.getBoundingClientRect().top &lt;= this.height + 1 : false;
      this._state.searchIsAtTop = leadspaceSearchBar ? leadspaceSearchBar.getBoundingClientRect().top &lt;= this.height + 1 : false;
      this._state.tocIsAtSearch = leadspaceSearchBar &amp;&amp; tableOfContentsInnerBar ? tableOfContentsInnerBar.getBoundingClientRect().top &lt;= leadspaceSearchBar.getBoundingClientRect().bottom : false;
      this._state.mastheadL0IsActive = Boolean(masthead === null || masthead === void 0 ? void 0 : masthead.querySelector('[expanded]'));
      this._state.mastheadL1IsActive = mastheadL1 &amp;&amp; mastheadL1.hasAttribute('active');
      var _this$_state = this._state,
        tocShouldStick = _this$_state.tocShouldStick,
        tocIsAtTop = _this$_state.tocIsAtTop,
        searchIsAtTop = _this$_state.searchIsAtTop,
        tocIsAtSearch = _this$_state.tocIsAtSearch,
        mastheadL0IsActive = _this$_state.mastheadL0IsActive,
        mastheadL1IsActive = _this$_state.mastheadL1IsActive;

      // Begin calculating maxScrollAway.

      // If L0 is open, lock it to the top of the page.
      if (mastheadL0 &amp;&amp; mastheadL0IsActive) {
        this._state.maxScrollaway = 0;
      }
      // If L1 is open, lock it to the top of the page.
      else if (mastheadL1IsActive &amp;&amp; mastheadL0) {
        this._state.maxScrollaway = mastheadL0.offsetHeight;
      } else {
        // In cases where we have both an eligible ToC and leadspace search, we want
        // the ToC to take precedence. Scroll away leadspace search.
        if (searchIsAtTop &amp;&amp; tocIsAtSearch &amp;&amp; tocShouldStick) {
          this._state.maxScrollaway += leadspaceSearchBar.offsetHeight;
        }

        // Scroll away entire masthead if either ToC or leadspace search is eligible
        // to be the stuck element (unless L1 is open). Otherwise, scroll away the
        // L0 if we have an L1.
        if (searchIsAtTop || tocIsAtTop &amp;&amp; tocShouldStick) {
          if (masthead) {
            this._state.maxScrollaway += masthead.offsetHeight;
          }
        } else if (masthead &amp;&amp; mastheadL0 &amp;&amp; mastheadL1) {
          this._state.maxScrollaway += mastheadL0.offsetHeight;
        }
      }
    }

    /**
     * Positions sticky elements. Does so by checking the scroll position and where
     * tracked elements are in relation to it, then applying the correct styles to
     * each element in succession to ensure that only one element is stuck to the
     * top of the page, and all other elements that have been scrolled past can be
     * revealed when scrolling back up.
     */
  }, {
    key: "_positionElements",
    value: function _positionElements() {
      var _this$_elements4 = this._elements,
        banner = _this$_elements4.banner,
        masthead = _this$_elements4.masthead,
        tocInner = _this$_elements4.tableOfContentsInnerBar,
        leadspaceSearchBar = _this$_elements4.leadspaceSearchBar;
      var oldY = this._state.scrollPosPrevious;

      /**
       * Reset to a value that is equal to the difference between the previous
       * scrollY and the current scrollY values, but is positively and negatively
       * limited.
       *
       * Positive limit: 0
       *   all elements visible, starting at the top of the viewport.
       *
       * Negative limit: maxScrollaway * -1
       *   all elements that should be hidden are positioned above the viewport
       *   with the elements that should be visible starting at the top of the
       *   viewport.
       */
      this._state.cumulativeOffset = Math.max(Math.min((masthead ? masthead.offsetTop : 0) + oldY - this._state.scrollPos, 0), this._state.maxScrollaway * -1);

      /**
       * Handle each potentially sticky element in the order we expect them to
       * appear on the page. Important to do this sequentially for
       * cumulativeOffset to be correctly calculated by the time each of these
       * methods accesses it.
       *
       * To-do: One idea for improving this so the execution order doesn't matter
       * is to collect our elements into an array ordered by document position,
       * then loop over that array and execute a corresponding handler method.
       */
      if (banner) {
        this._handleBanner();
      }
      if (masthead) {
        this._handleMasthead();
      }
      if (leadspaceSearchBar) {
        this._handleLeadspaceSearch();
      }
      if (tocInner) {
        this._handleToc();
      }
    }

    /**
     * Manages which elements are stuck and where they are positioned. We should
     * only have one element stuck to the top of the viewport as the page scrolls
     * down.
     */
  }, {
    key: "_manageStickyElements",
    value: function _manageStickyElements() {
      var localeModal = this._elements.localeModal;
      var scrollPosPrevious = this._state.scrollPos;

      // Exit early if locale modal is open.
      if (localeModal &amp;&amp; localeModal.hasAttribute('open')) {
        return;
      }

      // Store scroll positions.
      this._state.scrollPosPrevious = scrollPosPrevious;
      this._state.scrollPos = Math.max(0, window.scrollY);

      // Given the current state, calculate how elements should be positioned.
      this._calculateMaxScrollaway();
      this._positionElements();

      // Set custom property for use in stylesheets
      root.document.documentElement.style.setProperty(this.constructor.customPropertyName, "".concat(this._state.cumulativeOffset, "px"));
    }
  }], [{
    key: "global",
    get: function get() {
      if (!Object.prototype.hasOwnProperty.call(root, 'stickyHeader')) {
        root.stickyHeader = new StickyHeader();
      }
      return root.stickyHeader;
    }
  }, {
    key: "customPropertyName",
    get: function get() {
      return "--".concat(c4dPrefix, "-sticky-header-height");
    }
  }]);
}();
export default StickyHeader;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="ibmdotcom.module_settings.html">settings</a></li></ul><h3>Classes</h3><ul><li><a href="AnalyticsAPI.html">AnalyticsAPI</a></li><li><a href="DDOAPI.html">DDOAPI</a></li><li><a href="KalturaPlayerAPI.html">KalturaPlayerAPI</a></li><li><a href="LocaleAPI.html">LocaleAPI</a></li><li><a href="MarketingSearchAPI.html">MarketingSearchAPI</a></li><li><a href="MastheadLogoAPI.html">MastheadLogoAPI</a></li><li><a href="ProfileAPI.html">ProfileAPI</a></li><li><a href="SearchTypeaheadAPI.html">SearchTypeaheadAPI</a></li><li><a href="TranslationAPI.html">TranslationAPI</a></li><li><a href="VideoPlayerAPI.html">VideoPlayerAPI</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_getLocaleDefault">_getLocaleDefault</a></li><li><a href="global.html#_getLocaleFromBrowser">_getLocaleFromBrowser</a></li><li><a href="global.html#_getLocaleFromCookie">_getLocaleFromCookie</a></li><li><a href="global.html#altlangs">altlangs</a></li><li><a href="global.html#calculateTotalWidth">calculateTotalWidth</a></li><li><a href="global.html#decodeString">decodeString</a></li><li><a href="global.html#escapeRegExp">escapeRegExp</a></li><li><a href="global.html#focuswrap">focuswrap</a></li><li><a href="global.html#formatVideoCaption">formatVideoCaption</a></li><li><a href="global.html#formatVideoDuration">formatVideoDuration</a></li><li><a href="global.html#globalInit">globalInit</a></li><li><a href="global.html#ipcinfoCookie">ipcinfoCookie</a></li><li><a href="global.html#loadNonLatinPlex">loadNonLatinPlex</a></li><li><a href="global.html#markdownToHtml">markdownToHtml</a></li><li><a href="global.html#on">on</a></li><li><a href="global.html#parseAspectRatio">parseAspectRatio</a></li><li><a href="global.html#removeHtmlTagEntities">removeHtmlTagEntities</a></li><li><a href="global.html#sameHeight">sameHeight</a></li><li><a href="global.html#serialize">serialize</a></li><li><a href="global.html#smoothScroll">smoothScroll</a></li><li><a href="global.html#stripHTML">stripHTML</a></li><li><a href="global.html#uniqueid">uniqueid</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sun Aug 18 2024 15:53:15 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
